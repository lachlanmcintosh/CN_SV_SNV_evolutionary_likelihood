

# This file was *autogenerated* from the file everything.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_100 = Integer(100); _sage_const_0 = Integer(0); _sage_const_200 = Integer(200)# precompute
import sys
import os

args = sys.argv
i=int(args[_sage_const_1 ])
j=int(args[_sage_const_2 ])
n=int(args[_sage_const_3 ])
dimension=n
l=int(args[_sage_const_4 ])
p=args[_sage_const_5 ]


collated_output_file = "precomputed/collated_"+str(i)+"_"+str(j)+"_"+str(dimension)+"_"+p+".csv"
print("START")
print(collated_output_file)

import pickle
import numpy as np
from numpy import linalg as LA

if not os.path.isfile(collated_output_file):
  outfile = "precomputed/pre_mat"+str(n)+"_u"+str(i)+"_d"+str(j)+".pickle"
  if not os.path.isfile(outfile):
    m=load("matrix_"+str(n)+".sobj")
    m2 = m.subs(u=i/_sage_const_100 ,d=j/_sage_const_100 )
    m2 = m2.apply_map(RR)
    #m2 = m2.np(dtype='longdouble')
    m2 = m2.numpy(dtype='double')
    with open(outfile, 'wb') as m_data:
      pickle.dump(m2, m_data)
    #save(m2,outfile)


  #for i2 in range(101):
  #  for j2 in range(101):
  #    if m2[i2,j2] > 1:
  #      m2[i2,j2] = 1
  #    if m2[i2,j2] < 0:
  #      m2[i2,j2] = 0
  #    assert m2[i2,j2] >= 0 
  #    assert m2[i2,j2] <= 1

  # all_paths
  # need to also edit this for constrained paths that can't go to zero.

  l=sys.argv[_sage_const_4 ]
  path_combinations = sys.argv[_sage_const_5 ]
  file = "precomputed/pre_mat"+str(n)+"_u"+sys.argv[_sage_const_1 ]+"_d"+sys.argv[_sage_const_2 ]+".pickle"

  with open(file,'rb') as m_data:
    m = pickle.load(m_data)
  #m = load(file)
  with open("GD.pickle",'rb') as GD_data:
    G = pickle.load(GD_data)
  #G = load("GD.pickle")
  
  dimension = int(n) # int(file.split("pre_mat")[1].split("_")[0])
  m = m[:dimension,:dimension]
  G = G[:dimension,:dimension]

  # need to normalise all the rows still!!!!!

  for i in range(dimension):
    total = sum(sum(m[i,:]))
    for j in range(dimension):
      m[i,j] = m[i,j]/total

  all_paths = load("all_path_combinations_"+path_combinations+".sobj")
  #with open("all_path_combinations_"+path_combinations+".pickle",'rb') as path_combinations_data:
  #  all_paths = pickle.load(path_combinations_data)
  #
  single_paths = [x for x in all_paths if "G" not in x]

  powers_filename = file.split(".pickle")[_sage_const_0 ] + ".powers.pickle"
  if os.path.isfile(powers_filename):
    with open(powers_filename,'rb') as infile:
      powers = pickle.load(infile)
  else:
    powers = {}
  for path in single_paths:
    if int(path) not in powers:
      res = LA.matrix_power(m,int(path))
      powers[int(path)] = res
  with open(powers_filename,'wb') as infile:
    pickle.dump(powers,infile)
  
  #output = file.split(".sobj")[0] + ".precomputed.sobj"
  output = file.split(".pickle")[_sage_const_0 ] + ".precomputed.pickle"
  count = _sage_const_0 
  if os.path.isfile(output):
    try:
      with open(output,'rb') as precomputed_data:
        myd = pickle.load(precomputed_data)
      #myd = load(output)
    except:
      # delete the file
      os.remove(output)
      myd = {}
  else:
    myd = {}

  for path in all_paths:
    if path in myd:
      continue
    splits = path.split("G")
    G1 = _sage_const_0 
    G2 = _sage_const_0 
    if len(splits) == _sage_const_1 :
      pre = int(path)
      mid = _sage_const_0 
      post = _sage_const_0 
    if len(splits) == _sage_const_2 :
      pre = int(splits[_sage_const_0 ])
      mid = _sage_const_0 
      post = int(splits[_sage_const_1 ])
      G1 = _sage_const_1 
    if len(splits) == _sage_const_3 :
      pre = int(splits[_sage_const_0 ])
      mid = int(splits[_sage_const_1 ])
      post = int(splits[_sage_const_2 ])
      G1 = _sage_const_1 
      G2 = _sage_const_1 

    # compute the probabilities for this path:
    res = powers[pre] #LA.matrix_power(m,pre)
    if G1 > _sage_const_0 :
      res = np.matmul(res,G)
    res = np.matmul(res,powers[mid]) #LA.matrix_power(m,mid))
    if G2 > _sage_const_0 :
      res = np.matmul(res,G)
    res = np.matmul(res,powers[post]) #LA.matrix_power(m,post))

    #res = m^pre * G^(G1>0) * m^mid * G^(G2>0) * m^post

    myd[path] = res
    if count % _sage_const_200  == _sage_const_0 :
      with open(output,'wb') as precomputed_data:
        pickle.dump(myd,precomputed_data)
    count = count + _sage_const_1 

  with open(output,'wb') as precomputed_data:
    pickle.dump(myd,precomputed_data)

  # collate
  i = int(sys.argv[_sage_const_1 ])
  j = int(sys.argv[_sage_const_2 ])
  dimension = int(sys.argv[_sage_const_3 ])
  length = int(sys.argv[_sage_const_4 ])
  p = sys.argv[_sage_const_5 ]
  # iterate over all combinations of u and d and all paths and collate them into one data frame
  input_file = file.split(".pickle")[_sage_const_0 ] + ".precomputed.pickle"
  with open(input_file,'rb') as myd_data:
    myd = pickle.load(myd_data)
  out_text = ""
  for path in myd:
    m = myd[path] 
    line = str(i)+","+str(j)
    line = line+","+path+","
    line = line+",".join([str(x) for x in m[_sage_const_1 ,:]])+"\n"
    out_text += line
  
  with open(collated_output_file,'w') as output_file:
    output_file.write(out_text)

